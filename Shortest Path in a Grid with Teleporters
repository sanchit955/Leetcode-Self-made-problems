Problem Description

You are given a 2D grid of size m x n, where each cell can be:





'.': An empty cell that you can walk through.



'#': An obstacle that you cannot pass.



A letter from 'A' to 'Z': A teleporter. All cells with the same letter are connected, meaning you can instantly move from one to any other cell with the same letter without cost.

You start at position (0, 0) and need to reach position (m-1, n-1). You can move to adjacent cells (up, down, left, right) if they are not obstacles, with each such move counting as one move in the path length. Additionally, if you are on a teleporter cell, you can instantly teleport to any other cell with the same letter, and this teleportation does not count toward the path length.

Find the minimum number of moves required to go from (0, 0) to (m-1, n-1). If there is no path, return -1.

Constraints:





1 <= m, n <= 100



The grid contains at least two cells.



The start and end cells are always '.' or a letter, not '#'.



There can be multiple teleporters with the same letter.

Examples:

Example 1:

Input:

grid = [
  ['.', 'A', '.'],
  ['.', '#', '.'],
  ['.', 'A', '.']
]

Output: 2

Explanation: One possible path is (0,0) -> (0,1) ['A', 1 move] -> teleport to (2,1) ['A', 0 moves] -> (2,2) [1 move]. Total path length is 2 moves.

Example 2:

Input:

grid = [
  ['.', '.', '.'],
  ['.', '#', '.'],
  ['.', '.', '.']
]

Output: 4

Explanation: No teleporters are present, so the shortest path is a standard grid traversal, e.g., (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2), requiring 4 moves.

Example 3:

Input:

grid = [
  ['.', '#', 'A'],
  ['#', '#', '#'],
  ['B', '#', '.']
]

Output: -1

Explanation: No path exists from (0,0) to (2,2) due to obstacles.

Example 4:

Input:

grid = [
  ['A', '.'],
  ['.', 'A']
]

Output: 0

Explanation: Start at (0,0) ['A'] and teleport to (1,1) ['A'], requiring 0 moves.

Solution

Approach

The problem can be solved using Breadth-First Search (BFS) by treating the grid as a graph where each cell is a node, and edges connect adjacent cells as well as cells with the same teleporter letter.





Step 1: Preprocess the grid to group teleporter cells by their letter.



Step 2: Use a queue for BFS, starting from (0, 0) with distance 0.



Step 3: For each cell, explore its adjacent cells and, if it's a teleporter, also explore all other cells with the same letter without increasing the distance.



Step 4: Use a visited set to avoid revisiting cells.



Step 5: If the target cell is reached, return the distance; otherwise, return -1 if the queue is exhausted.

Solution Code

from collections import deque, defaultdict

def shortestPath(grid):
    if not grid or not grid[0]:
        return -1
    m, n = len(grid), len(grid[0])
    
    # Group teleporters by letter
    teleporters = defaultdict(list)
    for i in range(m):
        for j in range(n):
            if grid[i][j].isalpha():
                teleporters[grid[i][j]].append((i, j))
    
    # BFS
    queue = deque([(0, 0, 0)])  # (row, col, distance)
    visited = {(0, 0)}
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        row, col, dist = queue.popleft()
        if (row, col) == (m-1, n-1):
            return dist
        
        # Check adjacent cells
        for dr, dc in directions:
            r, c = row + dr, col + dc
            if 0 <= r < m and 0 <= c < n and grid[r][c] != '#' and (r, c) not in visited:
                visited.add((r, c))
                queue.append((r, c, dist + 1))
        
        # Check teleporters
        if grid[row][col].isalpha():
            for r, c in teleporters[grid[row][col]]:
                if (r, c) not in visited:
                    visited.add((r, c))
                    queue.append((r, c, dist))
    
    return -1

Test Cases

Test Case 1





Input: grid = [['.', 'A', '.'], ['.', '#', '.'], ['.', 'A', '.']]



Output: 2



Explanation: Path: (0,0) -> (0,1) ['A', 1 move] -> teleport to (2,1) ['A', 0 moves] -> (2,2) [1 move].

Test Case 2





Input: grid = [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]



Output: 4



Explanation: Standard shortest path without teleporters: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2).

Test Case 3





Input: grid = [['.', '#', 'A'], ['#', '#', '#'], ['B', '#', '.']]



Output: -1



Explanation: No path exists due to obstacles.

Test Case 4





Input: grid = [['A', '.'], ['.', 'A']]



Output: 0



Explanation: Start at (0,0) ['A'] and teleport to (1,1) ['A'], requiring 0 moves.

Test Case 5





Input: grid = [['A', 'B'], ['B', 'A']]



Output: 0



Explanation: Start at (0,0) ['A'], teleport to (1,1) ['A'], requiring 0 moves.

Test Case 6





Input: grid = [['.', 'B', '.'], ['A', '#', 'A'], ['.', 'B', '.']]



Output: 2



Explanation: Path: (0,0) -> (0,1) ['B', 1 move] -> teleport to (2,1) ['B', 0 moves] -> (2,2) [1 move].

Contributing

If you have suggestions for improvements or additional test cases, feel free to open an issue or submit a pull request.
